{"/home/travis/build/npmtest/node-npmtest-nw-builder/test.js":"/* istanbul instrument in package npmtest_nw_builder */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nw-builder/lib.npmtest_nw_builder.js":"/* istanbul instrument in package npmtest_nw_builder */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nw_builder = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nw_builder = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nw-builder/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nw-builder && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nw_builder */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nw_builder\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nw_builder.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_nw_builder.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nw_builder.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_nw_builder.__dirname + '/lib.npmtest_nw_builder.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nw-builder/node_modules/nw-builder/index.js":"module.exports = require('./lib');","/home/travis/build/npmtest/node-npmtest-nw-builder/node_modules/nw-builder/lib/index.js":"var Promise = require('bluebird');\nvar _ = require('lodash');\nvar inherits = require('inherits');\nvar EventEmitter = require('events').EventEmitter;\nvar fs = require('graceful-fs-extra');\nvar recursiveReaddirSync = require('recursive-readdir-sync');\nvar path = require('path');\nvar url = require('url');\nvar winresourcer = Promise.promisify(require('winresourcer'));\nvar spawn = require('child_process').spawn;\nvar semver = require('semver');\nvar platformOverrides = require('platform-overrides');\nvar deprecate = require('deprecate');\nvar detectCurrentPlatform = require('./detectCurrentPlatform.js');\n\nvar NwVersions = require('./versions');\nvar Version = require('./Version');\nvar Utils = require('./utils');\nvar Downloader = require('./downloader');\nvar platforms = require('./platforms');\n\n// We inherit from EventEmitter for logging\ninherits(NwBuilder, EventEmitter);\nmodule.exports = NwBuilder;\nfunction NwBuilder(options) {\n    var defaults = {\n        files: null,\n        appName: false,\n        appVersion: false,\n        platforms: ['osx32', 'osx64', 'win32', 'win64'],\n        currentPlatform: detectCurrentPlatform(),\n        version: 'latest',\n        buildDir: './build',\n        cacheDir: './cache',\n        downloadUrl: 'https://dl.nwjs.io/',\n        manifestUrl: 'https://nwjs.io/versions.json',\n        flavor: 'sdk',\n        buildType: 'default',\n        forceDownload: false,\n        macCredits: false,\n        macIcns: false,\n        macZip: null,\n        zip: null,\n        zipOptions: null,\n        macPlist: false,\n        winIco: null,\n        argv: process.argv.slice(2)\n    };\n    // Intercept the platforms and check for the legacy platforms of 'osx' and 'win' and\n    // replace with 'osx32', 'osx64', and 'win32', 'win64' respectively.\n    if(typeof options.platforms != 'undefined'){\n        if(options.platforms.indexOf('osx') >= 0){\n            options.platforms.splice(options.platforms.indexOf('osx'), 1, 'osx32', 'osx64');\n        }\n        if(options.platforms.indexOf('win') >= 0){\n            options.platforms.splice(options.platforms.indexOf('win'), 1, 'win32', 'win64');\n        }\n        if(options.platforms.indexOf('linux') >= 0){\n            options.platforms.splice(options.platforms.indexOf('linux'), 1, 'linux32', 'linux64');\n        }\n    }\n    // Assign options\n    this.options = _.defaults(options, defaults);\n\n    // Some Option checking\n    if(!this.options.files) {\n        throw new Error('Please specify some files');\n    }\n\n    if (this.options.platforms.length === 0)\n        throw new Error('No platform to build!');\n\n    // verify all the platforms specifed by the user are supported\n    // this + previous check assures as we have only buildable platforms specified\n    this.options.platforms.forEach(function(platform) {\n        if (!(platform in platforms))\n            throw new Error('Unknown platform ' + platform);\n    });\n\n    this._platforms = _.cloneDeep(platforms);\n\n    // clear all unused platforms\n    for (var name in this._platforms) {\n        if (this.options.platforms.indexOf(name) === -1)\n            delete this._platforms[name];\n    }\n}\n\nNwBuilder.prototype.build = function (callback) {\n    var hasCallback = (typeof callback === 'function'),\n        done = Promise.defer();\n\n    // Let's create a NWjs app\n    this.checkFiles().bind(this)\n        .then(this.resolveLatestVersion)\n        .then(this.checkVersion)\n        .then(this.platformFilesForVersion)\n        .then(this.downloadNwjs)\n        .then(this.preparePlatformSpecificManifests)\n        .then(this.createReleaseFolder)\n        .then(this.copyNwjs)\n        .then(this.handleMacApp)\n        .then(this.handleWinApp)\n        .then(this.zipAppFiles)\n        .then(this.mergeAppFiles)\n        .then(function (info) {\n            // the promise(s) resolves to nothing in some cases\n            var result = info || this;\n\n            if(hasCallback) {\n                callback(false, result);\n            } else {\n                done.resolve(result);\n            }\n        })\n        .catch(function (error) {\n            if(hasCallback) {\n                callback(error);\n            } else {\n                done.reject(error);\n            }\n        });\n\n    return hasCallback ? true : done.promise;\n};\n\nNwBuilder.prototype.run = function (callback) {\n    var hasCallback = (typeof callback === 'function'),\n        done = Promise.defer();\n\n    // Let's run this NWjs app\n    this.checkFiles().bind(this)\n        .then(this.resolveLatestVersion)\n        .then(this.checkVersion)\n        .then(this.platformFilesForVersion)\n        .then(this.downloadNwjs)\n        .then(this.runApp)\n        .then(function (info) {\n            if(hasCallback) {\n                callback(false, info);\n            } else {\n                done.resolve(info);\n            }\n        })\n        .catch(function (error) {\n            if(hasCallback) {\n                callback(true, error);\n            } else {\n                done.reject(error);\n            }\n        });\n\n    return hasCallback ? true : done.promise;\n};\n\n\nNwBuilder.prototype.checkFiles = function () {\n    var self = this;\n\n    return Utils.getFileList(this.options.files).then(function (data) {\n\n        self._appPkg = data.json;\n        self._files = data.files;\n\n        return Utils.getPackageInfo(self._appPkg).then(function (appPkg) {\n            self._appPkg = appPkg;\n\n            if(!self.options.appName || !self.options.appVersion) {\n                self.options.appName = (self.options.appName ? self.options.appName : appPkg.name);\n                self.options.appVersion = (self.options.appVersion ? self.options.appVersion : appPkg.version);\n            }\n        });\n    });\n\n};\n\nNwBuilder.prototype.resolveLatestVersion = function () {\n    var self = this;\n\n    if(self.options.version !== 'latest') return Promise.resolve();\n\n    return NwVersions.getLatestVersion(self.options.downloadUrl, self.options.manifestUrl, self.options.flavor).then(function(latestVersion){\n        self.emit('log', 'Latest Version: v' + latestVersion.version);\n        self.options.version = latestVersion.version;\n        return latestVersion;\n    });\n};\n\nNwBuilder.prototype.checkVersion = function () {\n    var version = this.options.version,\n        flavor = semver.valid(version) && semver.satisfies(version, '<0.12.3') ? 'sdk' : this.options.flavor,\n        self = this;\n\n    if(!semver.valid(version)){\n        return Promise.reject('The version ' + version + ' is not valid.');\n    }\n\n\n    var getVersionFromManifest = function(){\n        return NwVersions.getVersion({\n            desiredVersion: version,\n            downloadUrl: self.options.downloadUrl,\n            manifestUrl: self.options.manifestUrl,\n            flavor: flavor\n        });\n    };\n    var getVersion;\n\n    // if the user specified the exact version and all its platforms are cached, don't hit the manifest at all;\n    // just trust the ones are cached and assume they're supported\n    if(self.options.version !== 'latest'){\n        var areAllPlatformsCached = true;\n        this._forEachPlatform(function(name, platform){\n            var platformToCheck = platform;\n\n            if(semver.satisfies(self.options.version, '>=0.12.3')) {\n                platformToCheck = _.clone(platform);\n                platformToCheck.files = ['*']; // otherwise it'll try to check cache legacy version files\n            }\n\n            if(!self.isPlatformCached(name, platformToCheck, self.options.version)){\n                areAllPlatformsCached = false;\n            }\n        });\n        if(areAllPlatformsCached){\n            getVersion = Promise.resolve(new Version({\n                version: version,\n                flavor: flavor,\n                downloadUrl: self.options.downloadUrl,\n                supportedPlatforms: Object.keys(this._platforms)\n            }));\n        }\n        else {\n            // otherwise hit the manifest\n            getVersion = getVersionFromManifest();\n        }\n    }\n    else {\n        // otherwise hit the manifest\n        getVersion = getVersionFromManifest();\n    }\n\n\n    return getVersion\n        .then(function(version){\n            self._version = version;\n            self._version.flavor = flavor;\n            self.emit('log', 'Using v' + self._version.version + ' (' + ((self._version.flavor === '') ? 'normal' : self._version.flavor + ')'));\n            if(self._version.isLegacy) {\n                deprecate('NW.js / node-webkit versions <0.12.3 are deprecated.');\n            }\n        });\n};\n\nNwBuilder.prototype.platformFilesForVersion = function () {\n    var self = this;\n\n    this._forEachPlatform(function (name, platform) {\n        var satisfied = self.preparePlatformFiles(name, platform);\n\n        // need the second condition for newer NW.js versions\n        if (!(satisfied && !!self._version.platforms[name + \"-\" + self._version.flavor])) {\n            throw new Error(\"Unsupported NW.js version '\" + self._version.version + \" (\" + self._version.flavor + \")' for platform '\" + name + \"'\");\n        }\n    });\n\n    return true;\n};\n\nNwBuilder.prototype.downloadNwjs = function () {\n    var self = this,\n        downloads = [];\n\n    this._forEachPlatform(function (name, platform) {\n        self.setPlatformCacheDirectory(name, platform, self._version.version, self._version.flavor);\n        platform.url = self._version.platforms[name + '-' + self._version.flavor];\n\n        // Ensure that there is a cache folder\n        if(self.options.forceDownload) {\n            fs.removeSync(platform.cache);\n        }\n\n        fs.mkdirpSync(platform.cache);\n        self.emit('log', 'Create cache folder in ' + path.resolve(self.options.cacheDir, self._version.version + '-' + self._version.flavor));\n\n        if(!self.isPlatformCached(name, platform, self._version.version, self._version.flavor)) {\n            downloads.push(\n                Downloader.downloadAndUnpack(platform.cache, platform.url)\n                    .catch(function(err){\n                        if(err.statusCode === 404){\n                            self.emit('log', 'ERROR: The version '+self._version.version+ ' (' + self._version.flavor + ') does not have a corresponding build posted at ' + self.options.downloadUrl + '. Please choose a version from that list.');\n                        } else {\n                            self.emit('log', err.msg);\n                        }\n\n                        return Promise.reject('Unable to download NWjs.');\n                    })\n            );\n            self.emit('log', 'Downloading: ' + platform.url);\n        } else {\n            self.emit('log', 'Using cache for: ' + name);\n        }\n    });\n\n    return Promise.all(downloads)\n        .then(function(data) {\n            Downloader.clearProgressbar();\n            return data;\n        });\n};\n\nNwBuilder.prototype.buildGypModules = function () {\n    // @todo\n    // If we trigger a rebuild we have to copy\n    // the node_modules to a tmp location because\n    // we don't want to change the source files\n\n};\n\n\nNwBuilder.prototype.preparePlatformSpecificManifests = function(){\n\n    if(!(this._appPkg.platformOverrides && Object.keys(this._appPkg.platformOverrides).length)){\n        return true;\n    }\n\n    var self = this;\n\n    this._forEachPlatform(function (name, platform) {\n\n        var overrides = self._appPkg.platformOverrides;\n        if (overrides[name] || overrides[name.substr(0, name.length-2)]) {\n\n            platformOverrides({\n                options: self._appPkg,\n                platform: name\n            }, function(err, result){\n                if(err) throw(err);\n                platform.platformSpecificManifest = result;\n            });\n        }\n    });\n};\n\n\nNwBuilder.prototype.createReleaseFolder = function () {\n    var self = this,\n        releasePath,\n        directoryCreationPromises = [];\n\n    if (_.isFunction(self.options.buildType)) {\n        releasePath = self.options.buildType.call(self.options);\n    } else {\n        // buildTypes\n        switch(self.options.buildType) {\n            case 'timestamped':\n                releasePath = self.options.appName + ' - ' + Math.round(Date.now() / 1000).toString();\n                break;\n\n            case 'versioned':\n                releasePath = self.options.appName + ' - v' + self.options.appVersion;\n                break;\n\n            default:\n                releasePath = self.options.appName;\n        }\n    }\n\n    this._forEachPlatform(function (name, platform) {\n        directoryCreationPromises.push(new Promise(function(resolve, reject){\n            platform.releasePath = path.resolve(self.options.buildDir, releasePath, name);\n\n            // Ensure that there is a release Folder, delete and create it.\n            fs.remove(platform.releasePath, function(err){\n                if(err) return reject(err);\n\n                fs.mkdirp(platform.releasePath, function(err){\n                    if(err) return reject(err);\n\n                    self.emit('log', 'Create release folder in ' + platform.releasePath);\n                    resolve();\n                });\n\n            });\n        }));\n    });\n\n    return Promise.all(directoryCreationPromises);\n};\n\nNwBuilder.prototype.copyNwjs = function () {\n    var self = this,\n        copiedFiles = [];\n\n    this._forEachPlatform(function (name, platform) {\n        // >= v0.12.3\n        // Since we only have `*`, we're going to recursively get all the files, then copy them\n        // Since a .app is treated like a directory, we need to ignore files inside them and just copy them entirely\n        if(platform.files.length === 1 && platform.files[0] === '*'){\n            // convert all paths inside a .app, etc. to just point to the .app\n            // then remove duplicates\n            var files = recursiveReaddirSync(platform.cache).map(function(file){\n                var matches = file.match(/^(.+?(\\.app|\\.framework))/);\n                if(matches){\n                    return matches[1];\n                }\n                return file;\n            });\n\n            var totalFiles = _.uniq(files);\n            platform.files = totalFiles;\n\n            totalFiles.forEach(function(file){\n                var destFile = path.relative(platform.cache, file);\n                var options = {};\n\n                if(['nw', 'nwjs.app', 'nw.exe'].indexOf(destFile) !== -1){\n                    // ignore nwjs.app/Contents/Resources/*.lproj, otherwise the app name will show as nwjs.app in\n                    // Finder\n                    if(destFile === 'nwjs.app'){\n                        options.filter = function(filepath){\n                            return !/nwjs\\.app\\/Contents\\/Resources\\/[^.]+\\.lproj(\\/|$)/.test(filepath);\n                        };\n                    }\n                    // rename executable to app name\n                    destFile = self.options.appName + path.extname(destFile);\n                }\n\n                copiedFiles.push(Utils.copyFile(file, path.join(platform.releasePath, destFile), self, options));\n                platform.files.push(destFile);\n            });\n\n            return;\n        }\n\n        // legacy\n        platform.files.forEach(function (file, i) {\n            var destFile = file;\n            if(i===0) {\n                // rename executable to app name\n                destFile = self.options.appName + path.extname(file);\n                // save new filename back to files list\n                platform.files[0] = destFile;\n            }\n            copiedFiles.push(Utils.copyFile(path.resolve(platform.cache, file), path.resolve(platform.releasePath, destFile), self));\n        });\n    });\n\n    return Promise.all(copiedFiles);\n};\n\nNwBuilder.prototype.isPlatformNeedingZip = function(name, platform) {\n    var self = this,\n        needsZip = platform.needsZip;\n\n    if(name.indexOf('osx') === 0 && self.options.macZip != null) {\n        deprecate('macZip is deprecated. Use the zip option instead.');\n        needsZip = self.options.macZip;\n    } else if(self.options.zip != null) {\n        needsZip = self.options.zip;\n    }\n\n    return needsZip;\n};\n\nNwBuilder.prototype.zipAppFiles = function () {\n    var self = this;\n\n    // Check if zip is needed\n    var doAnyNeedZip = false,\n        _needsZip = false,\n        zipOptions = this.options.zipOptions;\n        numberOfPlatformsWithoutOverrides = 0;\n\n    self._zips = {};\n\n    this._forEachPlatform(function(name, platform) {\n        var needsZip = self.isPlatformNeedingZip(name, platform);\n\n        if(needsZip) {\n            var platformSpecific = !!platform.platformSpecificManifest;\n\n            self._zips[name] = { platformSpecific: platformSpecific };\n\n            numberOfPlatformsWithoutOverrides += !platformSpecific;\n        }\n\n        doAnyNeedZip = doAnyNeedZip || needsZip;\n    });\n\n    self._needsZip = doAnyNeedZip;\n\n    return new Promise(function(resolve, reject) {\n\n        if(!self._needsZip){\n            resolve();\n            return;\n        }\n\n\n        // create (or don't create) a ZIP for multiple platforms\n        new Promise(function(resolve, reject) {\n            if(numberOfPlatformsWithoutOverrides > 1){\n                Utils.generateZipFile(self._files, self, null, zipOptions).then(function (zip) {\n                    resolve(zip);\n                }, reject);\n            }\n            else {\n                resolve();\n            }\n        })\n            .then(function(platformAgnosticZip){\n                var zipPromises = [];\n\n                _.forEach(self._zips, function(zip, platformName){\n\n                    if(platformAgnosticZip && !zip.platformSpecific){\n                        zip.file = platformAgnosticZip;\n                        return;\n                    }\n\n                    zipPromises.push(Utils.generateZipFile(\n                        self._files,\n                        self,\n                        JSON.stringify(self._platforms[platformName].platformSpecificManifest),\n                        zipOptions\n                    ).then(function(file){\n                        zip.file = file;\n                    }));\n                });\n\n                Promise.all(zipPromises).then(resolve, reject);\n            }, reject);\n    });\n};\n\nNwBuilder.prototype.mergeAppFiles = function () {\n    var self = this;\n\n    var copyPromises = [];\n\n    this._forEachPlatform(function (name, platform) {\n        var zipping = self.isPlatformNeedingZip(name, platform);\n        // We copy the app files if we are on mac and don't force zip\n        if(!zipping) {\n            // no zip, copy the files\n            self._files.forEach(function (file) {\n                var dest;\n\n                if(name == 'osx32' || name === 'osx64') {\n                    dest = path.resolve(self.getResourcesDirectoryPath(platform), 'app.nw', file.dest);\n                } else {\n                    dest = path.resolve(platform.releasePath, file.dest);\n                }\n\n                if(file.dest === 'package.json' && platform.platformSpecificManifest){\n                    copyPromises.push(self.writePlatformSpecificManifest(platform, dest));\n                }\n                else {\n                    copyPromises.push(Utils.copyFile(file.src, dest, self));\n                }\n            });\n        } else if(name == 'osx32' || name == 'osx64') {\n            // zip just copy the app.nw\n            copyPromises.push(Utils.copyFile(\n                self.getZipFile(name),\n                path.resolve(self.getResourcesDirectoryPath(platform), 'app.nw'),\n                self\n            ));\n        } else {\n            var executableToMergeWith = self._version.isLegacy ? _.first(platform.files) : self.getExecutableName(name);\n\n            // We cat the app.nw file into the .exe / nw\n            copyPromises.push(Utils.mergeFiles(\n                path.resolve(platform.releasePath, executableToMergeWith),\n                self.getZipFile(name),\n                platform.chmod\n            ));\n        }\n    });\n\n    return Promise.all(copyPromises);\n};\n\nNwBuilder.prototype.getZipFile = function(platformName){\n    return this._zips[platformName] && this._zips[platformName].file || null;\n};\n\nNwBuilder.prototype.writePlatformSpecificManifest = function(platform, dest){\n    return new Promise(function(resolve, reject){\n        var pkgParentDirectory = path.join(dest, '../');\n        if(!fs.existsSync(pkgParentDirectory)) fs.mkdirpSync(pkgParentDirectory);\n\n        fs.writeFile(dest, JSON.stringify(platform.platformSpecificManifest), function(err){\n            if(err) return reject(err);\n            resolve();\n        });\n    });\n};\n\nNwBuilder.prototype.handleMacApp = function () {\n    var self = this,\n        allDone = [];\n\n    this._forEachPlatform(function (name, platform) {\n        if(['osx32', 'osx64'].indexOf(name) < 0) return;\n\n        // Let's first handle the mac icon\n        if(self.options.macIcns) {\n            if(semver.satisfies(self._version.version, '<=0.12.3')) {\n                allDone.push(Utils.copyFile(self.options.macIcns, path.resolve(self.getResourcesDirectoryPath(platform), 'nw.icns'), self));\n            }\n            else {\n                allDone.push(Utils.copyFile(self.options.macIcns, path.resolve(self.getResourcesDirectoryPath(platform), 'app.icns'), self));\n                allDone.push(Utils.copyFile(self.options.macIcns, path.resolve(self.getResourcesDirectoryPath(platform), 'document.icns'), self));\n            }\n        }\n\n        // Handle mac credits\n        if(self.options.macCredits) {\n            allDone.push(Utils.copyFile(self.options.macCredits, path.resolve(self.getResourcesDirectoryPath(platform), 'Credits.html'), self));\n        }\n\n        // Let's handle the Plist\n        var PlistPath = path.resolve(platform.releasePath, self.options.appName+'.app', 'Contents', 'Info.plist');\n\n        // If the macPlist is a string we just copy the file\n        if(typeof self.options.macPlist === 'string') {\n            allDone.push(Utils.copyFile(self.options.macPlist, PlistPath, self));\n        } else {\n            // Setup the Plist\n            var plistOptions = Utils.getPlistOptions(\n                {\n                    name: self.options.appName,\n                    version: self.options.appVersion,\n                    copyright: self._appPkg.copyright\n                },\n                self.options.macPlist\n            );\n\n            allDone.push(Utils.editPlist(PlistPath, PlistPath, plistOptions));\n        }\n    });\n\n    return Promise.all(allDone);\n};\n\nNwBuilder.prototype.handleWinApp = function () {\n    var self = this,\n        allDone = [];\n\n    this._forEachPlatform(function (name, platform) {\n        if(!self.options.winIco || ['win32', 'win64'].indexOf(name) < 0) return;\n\n        // build a promise chain\n        allDone.push(new Promise(function(resolve, reject) {\n            self.emit('log', 'Update ' + name + ' executable icon');\n            var executableName = self._version.isLegacy ? _.first(platform.files) : self.getExecutableName(name);\n            // Set icon\n            winresourcer({\n                operation: \"Update\",\n                exeFile: path.resolve(platform.releasePath, executableName),\n                resourceType: \"Icongroup\",\n                resourceName: \"IDR_MAINFRAME\",\n                lang: 1033, // Required, except when updating or deleting\n                resourceFile: path.resolve(self.options.winIco)\n            }, function(err) {\n                if(!err) { resolve(); }\n                else {\n                    reject('Error while updating the Windows icon.' +\n                        (process.platform !== \"win32\"\n                                ? ' Wine (winehq.org) must be installed to add custom icons from Mac and Linux.'\n                                : ''\n                        )\n                    );\n                }\n            });\n        }));\n    });\n\n    return Promise.all(allDone);\n};\n\nNwBuilder.prototype.runApp = function () {\n    var self = this;\n\n    var currentPlatform = this.options.currentPlatform;\n    var platform = this._platforms[currentPlatform];\n    // if the user is on Windows/OS X 64-bit, but there is no 64-bit build, try the 32-bit build\n    if(!platform){\n        if(['osx64', 'win64'].indexOf(this.options.currentPlatform) !== -1) {\n            currentPlatform = currentPlatform.split('64')[0] + '32';\n            platform = this._platforms[currentPlatform];\n\n            if(!platform) {\n                throw new Error('currentPlatform selected (' + this.options.currentPlatform + \") doesn't exist in selected platforms (\" +\n                    Object.keys(this._platforms).join(', ') + '). We also tried ' + currentPlatform + \" and that doesn't exist either\"\n                );\n            }\n        }\n        else {\n            throw new Error('currentPlatform selected (' + currentPlatform + \") doesn't exist in selected platforms (\" +\n                Object.keys(this._platforms).join(', ') + ')'\n            );\n        }\n    }\n\n    var runnable;\n    if(this._version.isLegacy) {\n        runnable = platform.getRunnable(this.options.version);\n    }\n    else {\n        if(currentPlatform.indexOf('osx') === 0){\n            runnable = 'nwjs.app/Contents/MacOS/nwjs'\n        }\n        else if(currentPlatform.indexOf('win') === 0) {\n            runnable = 'nw.exe'\n        }\n        else {\n            runnable = 'nw'\n        }\n    }\n    var executable = path.resolve(platform.cache, runnable);\n\n    self.emit('log', 'Launching App');\n    return new Promise(function(resolve, reject) {\n        var parentDirectory = (_.isArray(self.options.files) ? self.options.files[0] : self.options.files ).replace(/\\*[\\/\\*]*/,\"\");\n        var nwProcess = self._nwProcess = spawn(executable, ['--enable-logging', parentDirectory].concat(self.options.argv));\n\n        self.emit('appstart');\n\n        nwProcess.stdout.on('data', function(data) {\n            self.emit('stdout', data);\n        });\n\n        nwProcess.stderr.on('data', function(data) {\n            self.emit('stderr', data);\n        });\n\n        nwProcess.on('error', function(err) {\n            self.emit('log', 'App launch error: ' + err);\n            reject(err);\n        });\n\n        nwProcess.on('close', function(code) {\n            self._nwProcess = undefined;\n            self.emit('log', 'App exited with code ' + code);\n            resolve();\n        });\n    });\n};\n\nNwBuilder.prototype.isAppRunning = function () {\n    return this._nwProcess !== undefined;\n};\n\nNwBuilder.prototype.getAppProcess = function () {\n    return this._nwProcess;\n};\n\nNwBuilder.prototype._forEachPlatform = function (fn) {\n    _.forEach(this._platforms, function(platform, name) {\n        return fn(name, platform);\n    });\n};\n\n// Mac only\nNwBuilder.prototype.getResourcesDirectoryPath = function (platform) {\n    return path.resolve(platform.releasePath, this.options.appName+'.app', 'Contents', 'Resources');\n};\n\n// Don't use if legacy version\nNwBuilder.prototype.getExecutableName = function (platform) {\n    var executableExtension = '';\n\n    if(platform.indexOf('osx') === 0){\n        executableExtension = '.app';\n    }\n    else if(platform.indexOf('win') === 0){\n        executableExtension = '.exe';\n    }\n\n    return this.options.appName + executableExtension;\n};\n\nNwBuilder.prototype.setPlatformCacheDirectory = function (platformName, platform, version, flavor) {\n    if(!platform.cache) {\n        platform.cache = path.resolve(this.options.cacheDir, version + \"-\" + flavor, platformName);\n    }\n};\n\n\nNwBuilder.prototype.isPlatformCached = function (platformName, platform, version, flavor) {\n    this.setPlatformCacheDirectory(platformName, platform, version, flavor);\n    if (this.options.forceDownload) {\n        return false;\n    }\n    this.preparePlatformFiles(platformName, platform, version);\n    return Downloader.checkCache(platform.cache, platform.files);\n};\n\n// returns a Boolean; true if the desired platform is supported\nNwBuilder.prototype.preparePlatformFiles = function(platformName, platform, version) {\n    // return if platform.files is already prepared\n    if(Object.keys(platform.files)[0] !== Object.keys(platforms[platformName].files)[0]){\n        return true;\n    }\n\n    if(semver.satisfies(version, '<0.12.3')) {\n        return !Object.keys(platform.files).every(function (range) {\n            if (semver.satisfies(version, range)) {\n                platform.files = platform.files[range];\n                if ('string' === typeof platform.files) {\n                    platform.files = [platform.files];\n                }\n                return false;\n            }\n            return true;\n        });\n    }\n\n    platform.files = ['*']; // otherwise bad stuff will happen like at attempt to download legacy version files\n    // all we can do here is assume it's oke because this._version might not exist yet, but callers of this function\n    // will check properly where necessary\n    return true;\n};\n","/home/travis/build/npmtest/node-npmtest-nw-builder/node_modules/nw-builder/lib/detectCurrentPlatform.js":"/*\n\tdetect the current platform according to expected constants\n\n\treturn undefined if platform is unrecognized\n*/\nmodule.exports = function () {\n\tswitch(process.platform) {\n        case 'darwin':\n            return process.arch === 'x64' ? 'osx64' : 'osx32';\n\n        case 'win32':\n            return (process.arch === 'x64' || process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432')) ? 'win64' : 'win32';\n\n        case 'linux':\n            return process.arch === 'x64' ? 'linux64' : 'linux32';\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-nw-builder/node_modules/nw-builder/lib/versions.js":"var Promise = require('bluebird');\nvar platforms = require('./platforms');\nvar semver = require('semver');\nvar request = require('request');\nvar _ = require('lodash');\nvar Version = require('./Version');\n\n/**\n * @param {string} url\n * @param {object} options - Passed to request\n * @returns {promise} which resolves to response body\n */\nfunction get(url, options){\n    var deferred = Promise.defer();\n\n    request(url, options, function (err, res, body) {\n        if (err) {\n            deferred.reject(err);\n        } else if (res.statusCode !== 200) {\n            deferred.reject('Received status code ' + res.statusCode + ': ' + url);\n        } else {\n            deferred.resolve(body);\n        }\n    });\n\n    return deferred.promise;\n}\n\n/**\n * @param {string} downloadUrl\n * @returns {promise} which resolves to an array of {Version}s\n */\nfunction getLegacyVersions(downloadUrl, flavor){\n    var scrapePtrn = /href=\"v?([0-9]+\\.[0-9]+\\.[0-9]+[^\"]*)\\/\"/ig,\n        searchRes,\n        versions = [];\n\n    return get(downloadUrl).then(function(body){\n        // scrapes valid semver versions from apache directory listing\n        while ((searchRes = scrapePtrn.exec(body)) !== null) {\n            searchRes = searchRes[1];\n            if( semver.valid(searchRes) && !_.includes(versions, searchRes) ) {\n                versions.push(searchRes);\n            }\n        }\n        // order with newest version at front of array\n        versions = versions.sort(function(a,b){ return semver.compare(b,a); });\n\n        // filter out invalid / alpha versions\n        var validationPromises = [];\n        versions.forEach(function(version){\n            if(!isLegacyVersion(version)){\n                return;\n            }\n            validationPromises.push(new Promise(function(resolve, reject){\n                // check if windows 64-bit ZIP exists\n                var win32Url = new Version({\n                    version: version,\n                    flavors: ['sdk'],\n                    supportedPlatforms: ['win32'],\n                    downloadUrl: downloadUrl\n                }).platforms['win32-sdk'];\n                request.head(win32Url, function(err, res){\n                    // note: this takes a version string and replaces it with an object (will be converted back later)\n                    resolve({\n                        version: version,\n                        flavor: ['sdk'],\n                        valid: !err && res.statusCode === 200\n                    });\n                });\n\n            }));\n        });\n\n        var allPlatforms = Object.keys(platforms);\n\n        return Promise.all(validationPromises)\n            .then(function(versions){\n                // convert back to array of version strings (filtered)\n                return versions.filter(function(versionObj){\n                        return versionObj.valid;\n                    })\n                    .map(function(versionObj){\n                        return new Version({\n                            version: versionObj.version,\n                            flavors: versionObj.flavor,\n                            supportedPlatforms: allPlatforms,\n                            downloadUrl: downloadUrl\n                        });\n                    });\n            });\n    });\n}\n\n/**\n * @param {string?} manifestUrl\n * @returns {promise} which resolves to response body\n */\nfunction getManifest(manifestUrl){\n    if (!manifestUrl){\n        manifestUrl='https://nwjs.io/versions.json';\n    }\n    return get(manifestUrl, { json: true }).then(function(body){\n        return body;\n    });\n}\n\n/**\n * @param {string} downloadUrl\n * @param {string} manifestUrl\n * @param {string} flavor\n * @returns {promise} which resolves to an array of {Version}s\n */\nfunction getVersionsFromManifest(downloadUrl, manifestUrl, flavor){\n    var mapFilesToPlatforms = function(files){\n        return files.map(function(file){\n            // convert win-x64 to win64, linux-ia32 to linux 32, etc.\n            return file.replace(/-(x|ia)/, '');\n        });\n    };\n\n    return getManifest(manifestUrl).then(function(manifest){\n        return manifest.versions\n            .filter(function(versionFromManifest){\n                // 0.12.3 is an exception that is in the manifest but is kind of a legacy version\n                return (versionFromManifest.flavors !== undefined) && ( versionFromManifest.flavors.indexOf('sdk') !== -1 || versionFromManifest.version === 'v0.12.3');\n            })\n            .map(function(versionFromManifest){\n                return new Version({\n                    version: versionFromManifest.version.replace('v', ''),\n                    flavors: versionFromManifest.flavors,\n                    supportedPlatforms: mapFilesToPlatforms(versionFromManifest.files),\n                    downloadUrl: downloadUrl\n                });\n            });\n    });\n}\n\n/**\n * @param {string} version\n * @returns {boolean}\n */\nfunction isLegacyVersion(version){\n    return semver.satisfies(version, '<0.12.3');\n}\n\nmodule.exports = {\n    /**\n     * Gets the latest stable version\n     * @param {string} downloadUrl\n     * @param {string} manifestUrl\n     * @param {string} flavor\n     * @returns {promise} which resolves to a {Version}\n     */\n    getLatestVersion: function(downloadUrl, manifestUrl, flavor) {\n        return getManifest(manifestUrl)\n            .then(function(manifest) {\n                return {\n                    desiredVersion: manifest.stable.replace('v', ''),\n                    downloadUrl: downloadUrl,\n                    manifestUrl: manifestUrl,\n                    flavor: flavor\n                }\n            })\n            .then(this.getVersion);\n    },\n    /**\n     * @param {string} args.desiredVersion\n     * @param {string} args.downloadUrl\n     * @param {string} args.manifestUrl\n     * @param {string} args.flavor\n     * @returns {promise} which resolves to a {Version}\n     */\n    getVersion: function(args){\n        return (isLegacyVersion(args.desiredVersion) ? getLegacyVersions : getVersionsFromManifest)(args.downloadUrl, args.manifestUrl)\n            .then(function(versions) {\n                var version = versions.findIndex(function(version){\n                    return version.version === args.desiredVersion;\n                });\n\n                return version >= 0\n                    ? Promise.resolve(versions[version])\n                    : Promise.reject('Version ' + args.desiredVersion + ' not found.');\n            });\n    },\n    /**\n     * @param {string} downloadUrl\n     * @param {string} manifestUrl\n     * @param {string} flavor\n     * @returns {promise} which resolves to an array of {Version}s\n     */\n    getVersions: function(downloadUrl, manifestUrl, flavor){\n        return Promise.all([\n            getVersionsFromManifest(downloadUrl, manifestUrl, flavor),\n            getLegacyVersions(downloadUrl, flavor)\n        ])\n            .then(function(versionLists){\n                return versionLists[0].concat(versionLists[1]);\n            });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-nw-builder/node_modules/nw-builder/lib/platforms.js":"var semver = require('semver');\n\nmodule.exports = {\n    win32: {\n        needsZip: true,\n        getRunnable: function() { return 'nw.exe'; },\n        files: { // First file must be the executable\n            '<=0.9.2': ['nw.exe', 'ffmpegsumo.dll', 'icudt.dll', 'libEGL.dll', 'libGLESv2.dll', 'nw.pak'],\n            '>0.9.2 <0.12.0': ['nw.exe', 'ffmpegsumo.dll', 'icudtl.dat', 'libEGL.dll', 'libGLESv2.dll', 'nw.pak', 'locales'],\n            '>=0.12.0': ['nw.exe', 'ffmpegsumo.dll', 'icudtl.dat', 'libEGL.dll', 'libGLESv2.dll', 'nw.pak', 'locales', 'd3dcompiler_47.dll', 'pdf.dll']\n        },\n        versionNameTemplate: 'v${ version }/${ name }-v${ version }-win-ia32.zip'\n    },\n    win64: {\n        needsZip: true,\n        getRunnable: function() { return 'nw.exe'; },\n        files: { // First file must be the executable\n            '<=0.9.2': ['nw.exe', 'ffmpegsumo.dll', 'icudt.dll', 'libEGL.dll', 'libGLESv2.dll', 'nw.pak', 'locales'],\n            '>0.9.2 <0.12.0': ['nw.exe', 'ffmpegsumo.dll', 'icudtl.dat', 'libEGL.dll', 'libGLESv2.dll', 'nw.pak', 'locales'],\n            '>=0.12.0': ['nw.exe', 'ffmpegsumo.dll', 'icudtl.dat', 'libEGL.dll', 'libGLESv2.dll', 'nw.pak', 'locales', 'd3dcompiler_47.dll', 'pdf.dll']\n        },\n        versionNameTemplate: 'v${ version }/${ name }-v${ version }-win-x64.zip'\n    },\n    osx32: {\n        needsZip: false,\n        getRunnable: function(version) {\n            if(semver.satisfies(version, '>=0.12.0 || ~0.12.0-alpha')) {\n                return 'nwjs.app/Contents/MacOS/nwjs';\n            } else {\n                return 'node-webkit.app/Contents/MacOS/node-webkit';\n            }\n        },\n        files: {\n            '<0.12.0-alpha': ['node-webkit.app'],\n            '>=0.12.0 || ~0.12.0-alpha': ['nwjs.app']\n        },\n        versionNameTemplate: 'v${ version }/${ name }-v${ version }-osx-ia32.zip'\n    },\n    osx64: {\n        needsZip: false,\n        getRunnable: function(version) {\n            if(semver.satisfies(version, '>=0.12.0 || ~0.12.0-alpha')) {\n                return 'nwjs.app/Contents/MacOS/nwjs';\n            } else {\n                return 'node-webkit.app/Contents/MacOS/node-webkit';\n            }\n        },\n        files: {\n            '<0.12.0-alpha': ['node-webkit.app'],\n            '>=0.12.0 || ~0.12.0-alpha': ['nwjs.app']\n        },\n        versionNameTemplate: 'v${ version }/${ name }-v${ version }-osx-x64.zip'\n    },\n    linux32: {\n        needsZip: true,\n        chmod: '0755',\n        getRunnable: function() { return 'nw'; },\n        files: { // First file must be the executable\n            '<=0.9.2': ['nw', 'nw.pak', 'libffmpegsumo.so'],\n            '>0.9.2 <=0.10.1': ['nw', 'nw.pak', 'libffmpegsumo.so', 'icudtl.dat'],\n            '>0.10.1':         ['nw', 'nw.pak', 'libffmpegsumo.so', 'icudtl.dat', 'locales']\n        },\n        versionNameTemplate: 'v${ version }/${ name }-v${ version }-linux-ia32.tar.gz'\n    },\n    linux64: {\n        needsZip: true,\n        chmod: '0755', // chmod file file to be executable\n        getRunnable: function() { return 'nw'; },\n        files: { // First file must be the executable\n            '<=0.9.2': ['nw', 'nw.pak', 'libffmpegsumo.so'],\n            '>0.9.2 <=0.10.1': ['nw', 'nw.pak', 'libffmpegsumo.so', 'icudtl.dat'],\n            '>0.10.1':         ['nw', 'nw.pak', 'libffmpegsumo.so', 'icudtl.dat', 'locales']\n        },\n        versionNameTemplate: 'v${ version }/${ name }-v${ version }-linux-x64.tar.gz'\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-nw-builder/node_modules/nw-builder/lib/Version.js":"var platforms   = require('./platforms');\nvar _           = require('lodash');\nvar semver      = require('semver');\n\n/**\n * Represents a version.\n * @constructor\n * @param {string} args.version.\n * @param {array} args.supportedPlatforms - array of strings like `osx64`.\n * @param {string} args.downloadUrl.\n */\nmodule.exports = function Version(args){\n    var generatePlatformUrls,\n        result = {\n            isLegacy: semver.satisfies(args.version, '<0.12.3'),\n            name: semver.satisfies(args.version, '>=0.12.0 || ~0.12.0-alpha') ? 'nwjs' : 'node-webkit',\n            version: args.version\n        };\n\n    // 0.12.3 is an exception that is in the manifest but is pretty much a legacy version\n    if(result.isLegacy || args.version === '0.12.3'){\n        generatePlatformUrls = function(version,flavors, supportedPlatforms){\n            var platformUrls = {};\n            supportedPlatforms.forEach(function (supportedPlatform) {\n                flavors.forEach(function(flavor) {\n                    platformUrls[supportedPlatform + '-' + flavor] = args.downloadUrl + _.template(platforms[supportedPlatform].versionNameTemplate)(result);\n                });\n            });\n            return platformUrls;\n        };\n    }\n    else {\n        var fixPlatformName = function(platform){\n            return platform.replace('32', '-ia32').replace('64', '-x64');\n        };\n\n        var mapPlatformToExtension = function(platform){\n            if(platform.indexOf('linux') === 0){\n                return 'tar.gz'\n            }\n\n            return 'zip'\n        };\n\n        generatePlatformUrls = function(version, flavors, supportedPlatforms){\n            var platformUrls = {};\n            supportedPlatforms.forEach(function(platform){\n                flavors.forEach(function(flavor) {\n                    platformUrls[platform + '-' + flavor] = args.downloadUrl + 'v' + version + '/nwjs' + (flavor === 'normal' ? '' : '-' + flavor) + '-v' + version + '-' + fixPlatformName(platform)\n                        + '.' + mapPlatformToExtension(platform);\n                });\n            });\n            return platformUrls;\n        };\n    }\n\n    result.platforms = generatePlatformUrls(args.version, args.flavors, args.supportedPlatforms);\n    return result;\n};","/home/travis/build/npmtest/node-npmtest-nw-builder/node_modules/nw-builder/lib/utils.js":"var fs = require('graceful-fs-extra');\nvar path = require('path');\nvar _ = require('lodash');\nvar Promise = require('bluebird');\nvar plist = require('plist');\nvar Glob = require('simple-glob');\nvar temp = require('temp');\nvar archiver = require('archiver');\n\nvar readFile = Promise.promisify(fs.readFile);\nvar writeFile = Promise.promisify(fs.writeFile);\n\n// Automatically track and cleanup files at exit\ntemp.track();\n\nmodule.exports = {\n    getPackageInfo: function(path) {\n        return new Promise(function(resolve, reject) {\n            fs.readFile(path, function (err, data) {\n                if (err) return reject(err);\n                try {\n                    var appPkg = JSON.parse(data);\n                } catch(e) {\n                    reject(\"Invalid package.json: \" + e + \"\\nMake sure the file is encoded as utf-8\");\n                    return;\n                }\n                if (!appPkg.name || !appPkg.version) {\n                    reject(\"Please make sure that your project's package.json includes a version and a name value\");\n                } else {\n                    resolve(appPkg);\n                }\n            });\n        });\n    },\n    getFileList: function(fileglob) {\n        var self = this,\n            jsonfile, destFiles = [],\n            srcFiles = [],\n            package_path,\n            matches = Glob(fileglob);\n\n        return new Promise(function(resolve, reject) {\n            if(!matches.length) return reject('No files matching');\n\n            matches.forEach(function(file) {\n                var internalFileName = path.normalize(file);\n                if (internalFileName.match('package.json')) {\n                    jsonfile = self.closerPathDepth(internalFileName, jsonfile);\n                    package_path = path.normalize(jsonfile.split('package.json')[0] || './');\n                }\n                if(!fs.lstatSync(internalFileName).isDirectory()) {\n                    srcFiles.push(internalFileName);\n                }\n            });\n\n            if (!jsonfile) {\n                return reject('Could not find a package.json in your src folder');\n            }\n\n            srcFiles.forEach(function(file) {\n                destFiles.push({\n                    src: file,\n                    dest: file.replace(package_path, '')\n                });\n            });\n\n            resolve({\n                files: destFiles,\n                json: jsonfile\n            });\n        });\n    },\n    closerPathDepth: function(path1, path2) {\n        if (!path2) { return path1; }\n\n        var d1 = this.pathDepth(path1),\n            d2 = this.pathDepth(path2);\n\n        return d1 < d2 ? path1 : path2;\n    },\n    pathDepth: function(absolutePath) {\n        return absolutePath.split(path.sep).length;\n    },\n    copyFile: function (src, dest, _event, options) {\n        return new Promise(function(resolve, reject) {\n            options = options || {};\n            var stats = fs.lstatSync(src);\n            fs.copy(src, dest, options, function (err) {\n                if(err) return reject(err);\n\n                var retryCount = 0;\n                var existsCallback = function(exists){\n                    if(exists){\n                        fs.chmod(dest, stats.mode, function(err){\n                            // ignore error\n                            if (err) {\n                                _event.emit('log', 'chmod ' + stats.mode + ' on ' + dest + ' failed after copying, ignoring');\n                            }\n\n                            resolve();\n                        });\n                    } else if (retryCount++ < 2) {\n                        // This is antipattern!!!\n                        // Callback should be called when the copy is finished!!!!\n                        setTimeout(function(){\n                            fs.exists(dest, existsCallback);\n                        }, 1000);\n                    } else {\n                        reject(new Error(\"Copied file (\" + dest + \") doesn't exist in destination after copying\"));\n                    }\n                };\n\n                fs.exists(dest, existsCallback);\n            });\n        });\n    },\n    mergeFiles: function (app, zipfile, chmod) {\n        // we need to pipe the app into the zipfile and chmod it\n        return new Promise(function(resolve, reject) {\n            var zipStream = fs.createReadStream(zipfile),\n                writeStream = fs.createWriteStream(app, {flags:'a'});\n\n            zipStream.on('error', reject);\n            writeStream.on('error', reject);\n\n            writeStream.on('finish', function () {\n                if(chmod) {\n                    fs.chmodSync(app, chmod);\n                }\n                resolve();\n            });\n\n            zipStream.pipe(writeStream);\n        });\n    },\n    generateZipFile: function (files, _event, platformSpecificManifest, zipOptions) {\n        var destStream = temp.createWriteStream(),\n            archive = archiver('zip', zipOptions || {});\n\n        return new Promise(function(resolve, reject) {\n\n            // Resolve on close\n            destStream.on('close', function () {\n                resolve(destStream.path);\n            });\n\n            // Reject on Error\n            archive.on('error', reject);\n\n            // Add the files\n            var filesBulk = [];\n            files.forEach(function(file){\n                if(file.dest === 'package.json' && platformSpecificManifest){\n                    archive.append(platformSpecificManifest, {name: 'package.json'});\n                }\n                else\n                {\n                    filesBulk.push({\n                        src: file.src,\n                        data: { name: path.basename(file.dest) },\n                        expand: true,\n                        flatten: true,\n                        dest: path.dirname(file.dest)\n                    });\n                }\n            });\n            archive.bulk(filesBulk);\n\n            // Some logs\n            archive.on('entry', function (file) {\n                _event.emit('log', 'Zipping ' + file.name);\n            });\n\n            // Pipe the stream\n            archive.pipe(destStream);\n            archive.finalize();\n\n        });\n    },\n    getPlistOptions: function(parsedParams, custom) {\n        var obj = {};\n        if(parsedParams.name) {\n            obj.CFBundleName = parsedParams.name;\n            obj.CFBundleDisplayName = parsedParams.name;\n        }\n        if(parsedParams.version) {\n            obj.CFBundleVersion = parsedParams.version;\n            obj.CFBundleShortVersionString = 'Version ' + parsedParams.version;\n        }\n        if(parsedParams.copyright) {\n            obj.NSHumanReadableCopyright = parsedParams.copyright;\n        }\n\n        return _.merge(obj, custom);\n    },\n    editPlist: function(plistInput, plistOutput, options) {\n        options = options || {};\n\n        // Make sure all required properties are set\n        [\n            'CFBundleName',\n            'CFBundleDisplayName',\n            'CFBundleVersion',\n            'CFBundleShortVersionString'\n        ].forEach(function(prop) {\n                if(!options.hasOwnProperty(prop)) {\n                    throw new Error('Missing macPlist property \\'' + prop + '\\'');\n                }\n            });\n\n        // Bundle identifier based on package name\n        if(options.CFBundleIdentifier === undefined) {\n            options.CFBundleIdentifier = 'com.nw-builder.' + options.CFBundleName.toLowerCase().replace(/[^a-z\\-]/g,'');\n        }\n\n        // Read the input file\n        return readFile(plistInput, 'utf8')\n            // Parse it\n            .then(plist.parse)\n            // Then overwrite the properties with custom values\n            .then(function(info) {\n                // Keep backwards compatibility and handle aliases\n                Object.keys(options).forEach(function(key) {\n                    var value = options[key];\n                    switch(key) {\n                        case 'mac_bundle_id':\n                            info.CFBundleIdentifier = value;\n                            break;\n                        case 'mac_document_types':\n                            info.CFBundleDocumentTypes = value.map(function(type) {\n                                return {\n                                    CFBundleTypeName: type.name,\n                                    CFBundleTypeExtensions: type.extensions,\n                                    CFBundleTypeRole: type.role,\n                                    LSIsAppleDefaultForType: type.isDefault\n                                };\n                            });\n                            break;\n                        default:\n                            info[key] = value;\n                    }\n                });\n\n                // Remove some unwanted properties\n                if(!(options.hasOwnProperty('mac_document_types') || options.hasOwnProperty('CFBundleDocumentTypes'))) {\n                    info.CFBundleDocumentTypes = [];\n                }\n\n                if(!options.hasOwnProperty('UTExportedTypeDeclarations'))\n                    info.UTExportedTypeDeclarations = [];\n\n                // Write output file\n                return writeFile(plistOutput, plist.build(info));\n            });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-nw-builder/node_modules/nw-builder/lib/downloader.js":"var Promise = require('bluebird');\nvar request = require('request');\nvar progress = require('progress');\nvar fs = require('fs');\nvar path = require('path');\nvar zlib = require('zlib');\nvar tar = require('tar-fs');\nvar temp = require('temp');\nvar DecompressZip = require('decompress-zip');\nvar ncp = require('graceful-ncp').ncp;\nvar rimraf = require('rimraf');\n\n// Automatically track and cleanup files at exit\ntemp.track();\nvar isWin = /^win/.test(process.platform);\n\n// one progressbar for all downloads\nvar bar;\n\nmodule.exports = {\n    checkCache: function(cachepath, files) {\n        var missing;\n\n        // if the version is >=0.12.3, then we don't which files we want from the archives, so just check that the folder\n        // exists and has at least 3 files in it.\n        if(files.length === 1 && files[0] === '*'){\n            return fs.existsSync(cachepath) && fs.readdirSync(cachepath).length >= 3;\n        }\n\n        files.forEach(function(file) {\n            if (missing) {\n                return;\n            }\n            if (!fs.existsSync(path.join(cachepath, file))) {\n                missing = true;\n            }\n        });\n\n        return !missing;\n    },\n    clearProgressbar: function() {\n        bar && bar.terminate();\n        bar = null;\n    },\n    downloadAndUnpack: function(cachepath, url) {\n        var extention = path.extname(url),\n            done = Promise.defer(),\n            self = this,\n            rq = request(url),\n            len,\n            stream;\n\n        function format(statusCode) {\n            return statusCode + ': ' + require('http').STATUS_CODES[statusCode];\n        }\n\n        rq.proxy = true;\n        rq.on('error', function(err) {\n            bar && bar.terminate();\n            done.reject(err);\n        });\n        rq.on('response', function (res) {\n            len = parseInt(res.headers['content-length'], 10);\n            if (res.statusCode !== 200) {\n                done.reject({\n                    statusCode: res.statusCode,\n                    msg: 'Recieved status code ' + format(res.statusCode)\n                });\n            } else if (len) {\n                if (!bar) {\n                    bar = new progress('  downloading [:bar] :percent :etas', {\n                        complete: '=',\n                        incomplete: '-',\n                        width: 20,\n                        total: len\n                    });\n                } else {\n                    bar.total += len;\n                }\n            }\n        });\n        rq.on('data', function(chunk) {\n            len && bar && bar.tick(chunk.length);\n        });\n\n        if (extention === '.zip') {\n            stream = temp.createWriteStream();\n\n            stream.on('close', function() {\n                if(done.promise.isRejected()) return;\n                self.extractZip(stream.path, cachepath).then(self.stripRootFolder).then(function(files) {\n                    done.resolve(files);\n                });\n            });\n\n            rq.pipe(stream);\n        }\n\n        if (extention === '.gz') {\n            rq.on('response', function(res) {\n                if(res.statusCode !== 200) return;\n                self.extractTar(res, cachepath).then(self.stripRootFolder).then(function(files) {\n                    done.resolve(files);\n                });\n            });\n        }\n\n        return done.promise;\n    },\n    extractTar: function(tarstream, destination) {\n        var done = Promise.defer(),\n            gunzip = zlib.createGunzip(),\n            files = [];\n\n        tarstream\n            .pipe(gunzip)\n            .on('error', function(err){\n                done.reject(err);\n            })\n            .pipe(tar.extract(destination, {\n                umask: (isWin ? false : 0),\n                map: function(header) {\n                    files.push({path: path.basename(header.name)});\n                    return header;\n                }\n            }))\n            .on('finish', function() {\n                done.resolve({files:files, destination:destination});\n            });\n\n        return done.promise;\n    },\n    extractZip: function(zipfile, destination) {\n        var files = [],\n            done = Promise.defer();\n\n        new DecompressZip(zipfile)\n            .on('error', function(err){\n                done.reject(err);\n            })\n            .on('extract', function(log) {\n                // Setup chmodSync to fix permissions\n                files.forEach(function(file) {\n                    fs.chmodSync(path.join(destination, file.path), file.mode);\n                });\n\n                done.resolve({files:files, destination:destination});\n            })\n            .extract({\n                path: destination,\n                filter: function(entry) {\n                    files.push({\n                        path: entry.path,\n                        mode: entry.mode.toString(8)\n                    });\n\n                    return true;\n                }\n            });\n\n        return done.promise;\n    },\n    stripRootFolder: function(extracted){\n        var done = Promise.defer(),\n            files = extracted.files,\n            destination = extracted.destination,\n            rootFiles = fs.readdirSync(destination),\n            fromDir = path.join(destination, rootFiles.length === 1 ? rootFiles[0] : '');\n\n        // strip out root folder if it exists\n        if(rootFiles.length === 1 && fs.statSync(fromDir).isDirectory() ){\n            // strip folder from files\n            for (var i = 0; i < files.length; i++) {\n                var file = files[i];\n                file.path = path.relative(rootFiles[0], file.path);\n                if(file.path === '') {\n                    files.splice(i, 1);\n                    i--;\n                }\n            }\n            // move stripped folder to destination\n            ncp(fromDir, destination, function (err) {\n                if (err) done.reject();\n                else rimraf(fromDir, function(){\n                    done.resolve(files);\n                });\n            });\n        } else {\n            done.resolve(files);\n        }\n\n        return done.promise;\n    }\n};\n"}